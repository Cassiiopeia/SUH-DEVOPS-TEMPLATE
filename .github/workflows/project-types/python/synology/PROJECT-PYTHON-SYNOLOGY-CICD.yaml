# ===================================================================
# Python FastAPI CI/CD 배포 (Synology)
# ===================================================================
#
# deploy 브랜치 푸시 시 Docker 이미지를 빌드하고
# Synology NAS에 자동 배포합니다.
#
# ===================================================================
# 🔑 필수 GitHub Secrets
# ===================================================================
# ENV_FILE: .env 파일 내용
# DOCKERHUB_USERNAME: DockerHub 사용자명
# DOCKERHUB_TOKEN: DockerHub 액세스 토큰
# SERVER_HOST: 배포 서버 주소
# SERVER_USER: SSH 사용자명
# SERVER_PASSWORD: SSH 비밀번호
# ===================================================================
#
# 🔧 환경변수 설정 (env 섹션에서 설정)
# ===================================================================
#
# 🌐 포트 및 컨테이너:
# CONTAINER_INTERNAL_PORT: FastAPI 내부 포트 (기본: 8000)
# DEPLOY_PORT: 배포 포트
# CONTAINER_NAME: 컨테이너 이름 (기본: PROJECT_NAME)
#
# 📦 볼륨 마운트:
# ENABLE_VOLUME_MOUNT: 볼륨 마운트 활성화 (true/false)
# VOLUME_HOST_PATH: 호스트 볼륨 경로
# VOLUME_CONTAINER_PATH: 컨테이너 내부 마운트 경로
#
# 🔌 SSH 연결:
# SSH_PORT: SSH 포트 (기본: 2022)
# SSH_COMMAND_TIMEOUT: SSH 명령 타임아웃 (기본: 600s)
# SSH_CONNECTION_TIMEOUT: SSH 연결 타임아웃 (기본: 60s)
#
# ⏱️ 헬스체크:
# HEALTHCHECK_WAIT_SECONDS: 초기화 대기 시간 (기본: 10초)
# HEALTHCHECK_PATH: HTTP 엔드포인트 경로 (비어있으면 로그만 사용)
# HEALTHCHECK_MAX_RETRIES: HTTP 재시도 횟수 (기본: 5회)
# HEALTHCHECK_RETRY_INTERVAL: 재시도 간격 (기본: 3초)
# HEALTHCHECK_LOG_PATTERN: Fallback 로그 검색 패턴
#
# 💡 HEALTHCHECK_PATH 예시:
#   FastAPI: "/docs"
#   커스텀: "/api/v1/health"
# ===================================================================

name: PROJECT-PYTHON-SYNOLOGY-CICD

# ===================================================================
# 트리거 설정
# ===================================================================
on:
  push:
    branches:
      - deploy  # 프로덕션 배포
  workflow_dispatch:  # 수동 실행 허용

# ===================================================================
# 환경 변수 설정
# ===================================================================
env:
  # 프로젝트 고유 식별자
  PROJECT_NAME: "프로젝트명-ai"

  # 🌐 포트 설정
  DEPLOY_PORT: "8092"

  # 🐍 Python 설정
  PYTHON_VERSION: "3.13"

  # 🐳 컨테이너 이름 설정 (비워두면 PROJECT_NAME 사용)
  CONTAINER_NAME: ""

  # 🗂️ 볼륨 마운트 설정 (빈값이면 마운트 안함)
  ENABLE_VOLUME_MOUNT: "false"
  VOLUME_HOST_PATH: "/volume1/projects/프로젝트명/ai"
  VOLUME_CONTAINER_PATH: "/mnt/프로젝트명"

  # 🔌 SSH 연결 설정
  SSH_PORT: "2022"  # SSH 포트 (Synology 기본: 2022)
  SSH_COMMAND_TIMEOUT: "600s"  # SSH 명령 실행 타임아웃
  SSH_CONNECTION_TIMEOUT: "60s"  # SSH 연결 타임아웃

  # 🌐 컨테이너 포트 설정
  CONTAINER_INTERNAL_PORT: "8000"  # FastAPI 내부 포트

  # ⏱️ 헬스체크 설정
  HEALTHCHECK_WAIT_SECONDS: "10"  # 컨테이너 초기화 대기 시간 (초)
  HEALTHCHECK_PATH: "/docs"  # HTTP 엔드포인트 경로 (비어있으면 로그 패턴만 사용)
  HEALTHCHECK_MAX_RETRIES: "5"  # HTTP 재시도 횟수
  HEALTHCHECK_RETRY_INTERVAL: "3"  # 재시도 간격 (초)
  HEALTHCHECK_LOG_PATTERN: "Uvicorn running on"  # Fallback 로그 검색 패턴

jobs:
  # ===================================================================
  # 빌드 작업
  # ===================================================================
  build:
    name: Python FastAPI 애플리케이션 빌드
    runs-on: ubuntu-latest

    steps:
      # 1. 소스코드 체크아웃
      - name: 코드 체크아웃
        uses: actions/checkout@v4

      # 2. 디스크 공간 확보
      - name: 디스크 공간 확보
        run: |
          echo "📊 빌드 전 디스크 사용량:"
          df -h

          echo "🧹 불필요한 파일 정리 중..."
          sudo rm -rf /usr/share/dotnet || true
          sudo rm -rf /opt/ghc || true
          sudo rm -rf /usr/local/share/boost || true
          sudo rm -rf "$AGENT_TOOLSDIRECTORY" || true

          echo "🐳 Docker 시스템 정리 중..."
          docker system prune -af --volumes || true

          echo "📊 정리 후 디스크 사용량:"
          df -h

      # 3. .env 파일 생성
      - name: .env 파일 생성
        run: |
          cat > .env << 'EOF'
          ${{ secrets.ENV_FILE }}
          EOF
          echo "✅ .env 파일이 생성되었습니다"

      # 4. Docker 빌드 환경 설정
      - name: Docker 빌드환경 설정
        uses: docker/setup-buildx-action@v3

      # 5. DockerHub 로그인
      - name: DockerHub 로그인
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 6. Docker 이미지 빌드 및 푸시
      - name: Docker 이미지 빌드 및 푸시
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.PROJECT_NAME }}:${{ github.ref_name }}
          # GitHub Actions 캐시 사용 (로컬 디스크 공간 절약)
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # 7. 빌드 후 정리
      - name: 빌드 후 정리
        if: always()
        run: |
          echo "🧹 빌드 후 정리 중..."
          docker system prune -f || true
          echo "📊 최종 디스크 사용량:"
          df -h

  # ===================================================================
  # 배포 작업
  # ===================================================================
  deploy:
    name: 원격 서버 배포
    needs: build
    runs-on: ubuntu-latest

    steps:
      # SSH를 통한 원격 서버 배포 실행
      - name: Deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          password: ${{ secrets.SERVER_PASSWORD }}
          port: ${{ env.SSH_PORT }}
          command_timeout: ${{ env.SSH_COMMAND_TIMEOUT }}
          timeout: ${{ env.SSH_CONNECTION_TIMEOUT }}
          script: |
            set -e

            # ============================================================
            # 배포 환경 변수 설정
            # ============================================================
            echo "🔧 환경변수 설정.."
            export PATH=$PATH:/usr/local/bin
            export PW=${{ secrets.SERVER_PASSWORD }}

            # GitHub에서 전달받은 브랜치명
            BRANCH=${{ github.ref_name }}

            # 프로젝트 설정
            PROJECT_NAME="${{ env.PROJECT_NAME }}"

            # ============================================================
            # 포트 및 컨테이너명 설정
            # ============================================================
            PORT=${{ env.DEPLOY_PORT }}

            # 컨테이너 이름 설정
            if [ -z "${{ env.CONTAINER_NAME }}" ]; then
              CONTAINER_NAME="${PROJECT_NAME}"
              echo "ℹ️ CONTAINER_NAME이 설정되지 않아 PROJECT_NAME을 사용합니다: $CONTAINER_NAME"
            else
              CONTAINER_NAME="${{ env.CONTAINER_NAME }}"
              echo "ℹ️ 사용자 지정 CONTAINER_NAME 사용: $CONTAINER_NAME"
            fi

            echo "🚀 배포 환경으로 배포합니다 (브랜치: $BRANCH)"

            # 설정 정보 출력
            echo "📋 배포 설정 정보:"
            echo "  - 브랜치: $BRANCH"
            echo "  - 프로젝트: $PROJECT_NAME"
            echo "  - 컨테이너 이름: $CONTAINER_NAME"
            echo "  - 포트: $PORT"
            echo "  - Docker 이미지: ${{ secrets.DOCKERHUB_USERNAME }}/${PROJECT_NAME}:${BRANCH}"

            # ============================================================
            # Docker 이미지 풀 (Pull)
            # ============================================================
            echo "⬇️ Docker 이미지 풀: ${{ secrets.DOCKERHUB_USERNAME }}/${PROJECT_NAME}:${BRANCH}"
            echo $PW | sudo -S docker pull ${{ secrets.DOCKERHUB_USERNAME }}/${PROJECT_NAME}:${BRANCH}

            # ============================================================
            # 기존 컨테이너 정리
            # ============================================================
            echo "🧹 컨테이너 $CONTAINER_NAME 존재 여부 확인 중..."

            # 동일한 이름의 컨테이너가 존재하는지 확인
            if echo $PW | sudo -S docker ps -a --format '{{.Names}}' | grep -Eq "^${CONTAINER_NAME}\$"; then
              echo "⚠️ 컨테이너 $CONTAINER_NAME 이(가) 존재합니다. 중지 및 삭제 중..."
              echo $PW | sudo -S docker rm -f $CONTAINER_NAME
              echo "✅ 컨테이너 $CONTAINER_NAME 이(가) 삭제되었습니다."
            else
              echo "ℹ️ 존재하는 컨테이너 $CONTAINER_NAME 이(가) 없습니다."
            fi

            # ============================================================
            # 새 컨테이너 실행
            # ============================================================
            echo "🚀 새로운 컨테이너 $CONTAINER_NAME 실행 중..."

            # Docker 컨테이너 실행
            # - 포트 매핑: ${PORT}:${{ env.CONTAINER_INTERNAL_PORT }} (외부:내부)
            # - 시간대: Asia/Seoul
            # - 볼륨 마운트: 로컬 시간 동기화 및 프로젝트 데이터
            # ⚠️ .env 파일은 이미 Docker 이미지에 포함되어 있습니다

            # 볼륨 마운트 옵션 구성
            VOLUME_OPTS="-v /etc/localtime:/etc/localtime:ro"
            if [ "${{ env.ENABLE_VOLUME_MOUNT }}" == "true" ]; then
              # 디렉토리가 없으면 생성
              if [ ! -d "${{ env.VOLUME_HOST_PATH }}" ]; then
                echo "📁 볼륨 마운트 디렉토리 생성: ${{ env.VOLUME_HOST_PATH }}"
                echo $PW | sudo -S mkdir -p "${{ env.VOLUME_HOST_PATH }}"
              fi
              VOLUME_OPTS="$VOLUME_OPTS -v ${{ env.VOLUME_HOST_PATH }}:${{ env.VOLUME_CONTAINER_PATH }}"
              echo "📦 볼륨 마운트 활성화: $VOLUME_OPTS"
            else
              echo "ℹ️ 볼륨 마운트 비활성화됨"
            fi

            echo $PW | sudo -S docker run -d \
              -p ${PORT}:${{ env.CONTAINER_INTERNAL_PORT }} \
              --name $CONTAINER_NAME \
              -e TZ=Asia/Seoul \
              $VOLUME_OPTS \
              ${{ secrets.DOCKERHUB_USERNAME }}/${PROJECT_NAME}:${BRANCH}

            # ============================================================
            # 컨테이너 헬스체크
            # ============================================================
            echo "⏳ 컨테이너 초기화 대기 중... (${{ env.HEALTHCHECK_WAIT_SECONDS }}초)"
            sleep ${{ env.HEALTHCHECK_WAIT_SECONDS }}

            # 1단계: 컨테이너 프로세스 확인
            echo "🏥 컨테이너 헬스체크 중..."
            if ! echo $PW | sudo -S docker ps --format '{{.Names}}' | grep -Eq "^${CONTAINER_NAME}\$"; then
              echo "❌ 컨테이너 $CONTAINER_NAME 프로세스가 실행되지 않았습니다"
              echo $PW | sudo -S docker logs --tail 50 $CONTAINER_NAME || true
              exit 1
            fi
            echo "✅ 컨테이너 프로세스 실행 확인 완료"

            # 2단계: HTTP 엔드포인트 체크 (설정된 경우)
            HEALTHCHECK_SUCCESS=false
            if [ -n "${{ env.HEALTHCHECK_PATH }}" ]; then
              echo "🌐 HTTP 헬스체크 시작: http://localhost:${PORT}${{ env.HEALTHCHECK_PATH }}"

              for i in $(seq 1 ${{ env.HEALTHCHECK_MAX_RETRIES }}); do
                echo "  시도 $i/${{ env.HEALTHCHECK_MAX_RETRIES }}..."

                HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:${PORT}${{ env.HEALTHCHECK_PATH }} || echo "000")

                if [ "$HTTP_CODE" = "200" ]; then
                  echo "✅ HTTP 헬스체크 성공 (응답 코드: $HTTP_CODE)"
                  HEALTHCHECK_SUCCESS=true
                  break
                else
                  echo "⚠️ HTTP 헬스체크 실패 (응답 코드: $HTTP_CODE)"
                  if [ $i -lt ${{ env.HEALTHCHECK_MAX_RETRIES }} ]; then
                    echo "  ${{ env.HEALTHCHECK_RETRY_INTERVAL }}초 후 재시도..."
                    sleep ${{ env.HEALTHCHECK_RETRY_INTERVAL }}
                  fi
                fi
              done

              # HTTP 체크 실패 시 fallback으로 로그 패턴 매칭
              if [ "$HEALTHCHECK_SUCCESS" = "false" ]; then
                echo "⚠️ HTTP 헬스체크 최종 실패, 로그 패턴 매칭으로 fallback..."
              fi
            else
              echo "ℹ️ HEALTHCHECK_PATH가 설정되지 않아 로그 패턴 매칭만 사용합니다"
            fi

            # 3단계: 로그 패턴 매칭 (HTTP 실패 시 또는 HTTP 체크 비활성화 시)
            if [ "$HEALTHCHECK_SUCCESS" = "false" ]; then
              echo "📋 로그 패턴 매칭 시작: '${{ env.HEALTHCHECK_LOG_PATTERN }}'"

              if echo $PW | sudo -S docker logs $CONTAINER_NAME 2>&1 | grep -q "${{ env.HEALTHCHECK_LOG_PATTERN }}"; then
                echo "✅ 로그 패턴 매칭 성공: 애플리케이션이 정상적으로 시작되었습니다"
                HEALTHCHECK_SUCCESS=true
              else
                echo "❌ 로그 패턴 매칭 실패: 애플리케이션 시작 로그를 찾을 수 없습니다"
                echo ""
                echo "📋 디버깅 정보:"
                echo "  - 검색 패턴: ${{ env.HEALTHCHECK_LOG_PATTERN }}"
                echo "  - 컨테이너: $CONTAINER_NAME"
                echo "  - 이미지: ${{ secrets.DOCKERHUB_USERNAME }}/${PROJECT_NAME}:${BRANCH}"
                echo "  - 포트: ${PORT}:${{ env.CONTAINER_INTERNAL_PORT }}"
                echo "  - 볼륨: $VOLUME_OPTS"
                echo ""
                echo "📋 컨테이너 로그 (최근 50줄):"
                echo $PW | sudo -S docker logs --tail 50 $CONTAINER_NAME || true
                exit 1
              fi
            fi

            # 최종 성공 메시지
            if [ "$HEALTHCHECK_SUCCESS" = "true" ]; then
              echo "✅ 헬스체크 완료: 컨테이너 $CONTAINER_NAME 이(가) 정상적으로 실행 중입니다"
            fi

            # ============================================================
            # 배포 완료 확인
            # ============================================================
            echo "✅ 배포가 성공적으로 완료되었습니다!"
            echo ""
            echo "📋 배포 결과 요약:"
            echo "  🎯 프로젝트: $PROJECT_NAME"
            echo "  🌿 브랜치: $BRANCH"
            echo "  🐳 컨테이너: $CONTAINER_NAME"
            echo "  🌐 포트: $PORT"
            echo "  ⏰ 배포 시간: $(date '+%Y-%m-%d %H:%M:%S')"
            echo ""
            echo "🔗 접속 URL: http://${{ secrets.SERVER_HOST }}:${PORT}/docs"
